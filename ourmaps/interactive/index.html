<!DOCTYPE html>
<meta charset='utf-8'>

<style>

    .province {
      fill: #ccc;
    }

    .province.active {
      fill: blue;
      opacity: 0.5;
    }

    .concession {
      fill: #808080 ;
    }

    .background {
      fill: none;
      pointer-events: all;
    }

    .feature:hover {
        fill: red;
      opacity: 0.2;
    }


</style>

<svg width="800" height="600"></svg>

<!-- get d3 -->
<script src="https://d3js.org/d3.v4.min.js"></script>

<!-- js -->
<script> 

var svg = d3.select("svg")
  .on("click", stopped, true)
  ;

var active = d3.select(null),
  width = +svg.attr("width"),
  height = +svg.attr("height");

var zoom = d3.zoom()
  .scaleExtent([1,8])
  .on("zoom",zoomed)
  ;

svg.append("rect")
  .attr("class", "background")
  .attr("width", width)
  .attr("height", height)
  .on("click", reset)
;

var g = svg.append("g");

svg.call(zoom); // turn on for wheel zoom

d3.json("provinces.geojson", function(error, prov) {
    if (error) throw error;

    // make these global:
   projection = d3.geoMercator().fitSize([width, height], prov);
   path = d3.geoPath().projection(projection);

    g.selectAll('path')
      .data(prov.features)
      .enter()
      .append('path')
      .attr('d', path)
      .attr("class", "feature province")
      .style('stroke', 'black')
      .attr('fill', '#f1f4c7')
      .on("click", clicked);


})

d3.json("Conc_01_2018.geojson", function(error, conc) {
    if (error) throw error;

    // make these global:
   projection = d3.geoMercator().fitSize([width, height], conc);
   path = d3.geoPath().projection(projection);

    g.selectAll('path')
      .data(conc.features)
      .enter()
      .append('path')
      .attr('d', path)
      .attr("class", "feature concession")
      .style('stroke', 'black')
      .attr('fill', '#f1f4c7')
      .on("click", clicked);


})

function clicked(d) {
  if (active.node() === this) return reset();
  active.classed("active", false);
  active = d3.select(this).classed("active", true);

   var bounds = path.bounds(d),
       dx = bounds[1][0] - bounds[0][0],
       dy = bounds[1][1] - bounds[0][1],
       x = (bounds[0][0] + bounds[1][0]) / 2,
       y = (bounds[0][1] + bounds[1][1]) / 2,
       scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
       translate = [width / 2 - scale * x, height / 2 - scale * y];

console.log(scale)

   svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale) ) 
}

function reset() {
  active.classed("active", false);
  active = d3.select(null);

  svg.transition()
      .duration(750)
      .call( zoom.transform, d3.zoomIdentity ); 
}

function zoomed() {
  g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
  g.attr("transform", d3.event.transform);
}

// If the drag behavior prevents the default click,
// also stop propagation so we donâ€™t click-to-zoom.
function stopped() {
  if (d3.event.defaultPrevented) d3.event.stopPropagation();
}

</script>
